{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Vector Documentation","text":"<p>Here, you will learn about Vector's inner workings and CFW.</p>"},{"location":"1.%20History/history%20of%20anki.html","title":"History of Anki and Digital Dream Labs","text":"<ul> <li>mid 2017 - late 2018: Vector was created.<ul> <li>Anki wanted to create a Cozmo 2.0 of sorts. A Cozmo which could be fully autonomous.</li> <li>In order to create a robot which would actually sell, they created a new personality for this robot.</li> </ul> </li> <li>late 2018 - early 2019: Anki was creating many different products at the same time in order to try to stay afloat in a VC-led environment.<ul> <li>Bingo<ul> <li>There would have been a mini version and a big version.</li> <li>Both would roam the floor on two wheels, performing helpful tasks. Kind of like Amazon Astro</li> </ul> </li> <li>Pirouette<ul> <li>Appears to be a kiosk but cute.</li> <li>Not much is known.</li> <li>Might have been created for the company Anki's board planned to sell Anki to at some point.</li> </ul> </li> <li>Whiskey<ul> <li>Actually got pretty far into development.</li> <li>Essentially a Vector but with two extra ToF sensors on the face for much better spatial awareness (theoretically).</li> <li>Some DVT1 prototypes have made it out into the wild.</li> </ul> </li> </ul> </li> <li>April 29th, 2019: Anki announced their liquidation.</li> <li>May 1st, 2019: Anki officially went out of business.</li> <li>January 2020: Digital Dream Labs announced that they bought the assets.</li> <li>TODO: recount the misdoings of DDL in this time</li> <li>July 2023 - September 2024: DDL servers go down due to them not paying the bill for their AWS instance while they were still taking money from their customers</li> <li>September 2024: DDL gets new CEO Zack Anton and the servers come up a few weeks later.</li> <li>2024: <code>victor</code> and <code>vicOS-oelinux</code> leaked to github with encrypted keys.</li> <li>April 30th, 2025: Vector's keys get cracked and a unlock ota has been released to convert prod bots into dev bots.</li> </ul>"},{"location":"2.%20Available%20CFW/1.%20WireOS.html","title":"WireOS","text":"<p>WireOS is an OS created by Wire/kercre123.</p> <p>Wire's goal is to provide a stable, up-to-date, easily-buildable base for others to clone and modify.</p> <p>It is based off of the leaked 2.0.1.6076 source code.</p>"},{"location":"2.%20Available%20CFW/1.%20WireOS.html#changes-made-compared-to-normal-ddl-firmware","title":"Changes made compared to normal DDL firmware","text":"<ul> <li>More normal-looking eyes on Vector 2.0</li> <li>A fixed loosepixel animation</li> <li>\"unintentional performances\" and \"intentional performances\"<ul> <li>Anki-created PR which was never merged</li> <li>I don't know exactly what this entails, but it makes him do the binaryeyes and tangram animations on his own sometimes.</li> </ul> </li> <li>Fixes an EMR reading bug<ul> <li>In the original code, the LCD drawing code would read the EMR partition upon every single LCD draw (30 times per second). This seems to have caused I/O weirdness.</li> <li>It reads the EMR partition for the hardware model version. Vector 1.0 and 2.0 screens are different, and the code must adjust for that.</li> <li>I made it so it only reads on LCD init.</li> </ul> </li> <li>Uses the Picovoice Porcupine wakeword engine<ul> <li>You can customize it in the <code>wired</code> webserver.</li> </ul> </li> <li>Includes wired<ul> <li>\"Wire Daemon\"</li> <li>A special webserver program (at :8080) which is where custom wake word training happens, allows you to set the CPU/RAM frequency profile, and allows you to opt-out of auto-updates.</li> <li>This is added as part of the OTA creation, so you can only easily use it if you have a WireOS OTA installed.</li> </ul> </li> <li>Uses a Docker builder, so it can build (targeting Vector) on any x86_64 Linux machine</li> <li>Gamma correction<ul> <li>His camera now has much less trouble with brightly lit objects</li> </ul> </li> <li>Rainbow eyes<ul> <li>If chosen, his eyes will always cycle through all the hues</li> <li>(this can be chosen in :8888/demo.html)</li> </ul> </li> </ul>"},{"location":"2.%20Available%20CFW/2.%20Viccyware.html","title":"Viccyware","text":"<p>Viccyware is created by Switch-modder, and exists at The-Viccyware-Group.</p> <p>Website: https://viccyware.com</p>"},{"location":"2.%20Available%20CFW/2.%20Viccyware.html#what-does-it-do","title":"What does it do?","text":"<p>Viccyware embeds Cozmo animations, sounds, and behaviors, and morphs them into Vector's personality while maintaining the charm of both.</p> <p>Viccyware is available at froggitti's Dev Vector web setup.</p>"},{"location":"2.%20Available%20CFW/3.%20purplOS.html","title":"purplOS","text":"<p>purplOS is created by froggitti and is maintained at purpl-org/purplOS.</p> <p>purplOS is regular Vector firmware with Vector's personality, but has a purple theme, eye scanlines, and firmware 1.6.0.3331 sounds. It is meant to be a more vibrant version of Vector's default personality.</p> <p>purplOS is based off of wire-os.</p> <p>purplOS is available at froggitti's Dev Vector web setup.</p>"},{"location":"2.%20Available%20CFW/4.%20redOS.html","title":"redOS","text":"<p>redOS is created by ekeleze and froggitti, and is maintained at purpl-org/redOS.</p> <p>redOS is a red themed, \"experimental\" custom firmware which will introduce new/quirky features to Vector.</p> <p>Like purplOS, it has eye scanlines and sounds from 1.6.0.3331, and is based off of wire-os</p> <p>redOS is available at froggitti's Dev Vector web setup.</p>"},{"location":"2.%20Available%20CFW/5.%20RainbOS.html","title":"RainbOS","text":"<p>RainbOS is an OS created by GamingTime.</p> <p>RainbOS's purpose is to give GamingTime a way to learn about the world of coding, GitHub, Anki Vector, and tech.</p> <p>RainbOS is based off of WireOS, but with many added features.</p>"},{"location":"2.%20Available%20CFW/5.%20RainbOS.html#changes-made","title":"Changes Made","text":"<ul> <li>Colorful or \"rainbow\" backpack animations.</li> <li>RainbOS is meant to add some fun color to Anki Vector's build-in backpack lights. Each animation is carefully chosen to represent what emotion or situation Vector is in and reflect that in a fun new way.</li> <li>BlackJack Request to Play</li> <li>Anki had an old feature in prototype firmware where Vector would request to \"Play BlackJack?\" You could chose to start a game of BlackJack with Vector by saying yes, or decide to disapoint Vector with a no. Sadly, this feature was taken out before Vector's release. GamingTime added it back, and it is no fully functional once again.</li> <li>Many more small changes, which you can checkout on the RainbOS Repository.</li> <li>More to come in the future.</li> <li>RainbOS is a work-in-progress! As GamingTime's skills and understandings grow, so will the features of RainbOS. Stay tuned for the future!</li> </ul>"},{"location":"2.%20Available%20CFW/5.%20RainbOS.html#where-to-find","title":"Where to Find","text":"<p>You can find all RainbOS related things on its GitHub repository: RainbOS Repository.</p> <p>You can find installation instructions on the GitHub's repository README. A website is coming soon.</p>"},{"location":"3.%20Software%20Architecture/architecture.html","title":"Vector's Software Architecture","text":"<p>Vector's software is broken up into quite a few components.</p>"},{"location":"3.%20Software%20Architecture/architecture.html#the-main-os","title":"The main OS","text":"<p>Vector runs Embedded Linux built with Yocto, using the systemd init system. His processes run as regular daemons.</p>"},{"location":"3.%20Software%20Architecture/architecture.html#anki","title":"/anki","text":"<p>The /anki folder of the ext4 system partition is where the personality lives.</p> <p>Built programs are in /anki/bin, libraries in /anki/lib, data (like animations and sounds) exists in /anki/data/assets/cozmo_resources, and environment files exist in /anki/etc.</p> <p>The programs are the interesting parts. They communicate with each other via Unix sockets:</p>"},{"location":"3.%20Software%20Architecture/architecture.html#vic-engine","title":"vic-engine","text":"<ul> <li>Handles A.I. (such as vision processing), SLAM, and personality. All of the programs inside of Vector eventually communicate with this.</li> <li>C++</li> </ul>"},{"location":"3.%20Software%20Architecture/architecture.html#vic-anim","title":"vic-anim","text":"<ul> <li>Handles text-to-speech, animation playback, procedural eye rendering, sound playback, and wake-word recognition. For the most part, engine tells anim what to do, and anim performs it.</li> <li>C++</li> </ul>"},{"location":"3.%20Software%20Architecture/architecture.html#vic-robot","title":"vic-robot","text":"<ul> <li>Handles communication with the body.</li> <li>C++</li> </ul>"},{"location":"3.%20Software%20Architecture/architecture.html#vic-cloud","title":"vic-cloud","text":"<ul> <li>Handles communication with the cloud: voice data (after the wake-word), jdocs (user information/settings), token (authentication).</li> <li>Go</li> </ul>"},{"location":"3.%20Software%20Architecture/architecture.html#vic-gateway","title":"vic-gateway","text":"<ul> <li>Handles SDK communications. It hosts Vector's port :443. It essentially takes in gRPC requests, parses them, then tells engine what to do depending on the contents of the requests. It can also grab data from engine.</li> <li>Go</li> </ul>"},{"location":"3.%20Software%20Architecture/architecture.html#update-engine","title":"update-engine","text":"<ul> <li>Handles OTA updates. A user can initiate this via BLE (or over SSH directly), or systemd can initiate it. A systemd timer daemon is set to initiate this a few times a day to check for updates from whatever URL is set in /anki/etc/update-engine.env.</li> <li>Python<ul> <li>Orignal OS: Python 2.7.3</li> <li>Modern CFW: Python 3.13.2</li> </ul> </li> </ul>"},{"location":"3.%20Software%20Architecture/partitions.html","title":"Partitions","text":"<p>Vector's partition table is pretty similar to that of an Android phone, except he has a couple extra ones added by Anki.</p> <p>TODO</p>"},{"location":"3.%20Software%20Architecture/partitions.html#oem","title":"OEM","text":""},{"location":"3.%20Software%20Architecture/partitions.html#emr","title":"EMR","text":"<p>The EMR partiton (Electronic Medical Record) contains the calibration info of the robot as well as it's ESN.</p>"},{"location":"3.%20Software%20Architecture/partitions.html#boot_a-and-boot_b","title":"boot_a and boot_b","text":"<p>These are the boot partitions. These partitons contain a ramdisk which is loaded which will then load a system partition matching the slot ID you are in.</p>"},{"location":"3.%20Software%20Architecture/partitions.html#system_a-and-system_b","title":"system_a and system_b","text":"<p>Vector go Beep Boop.</p>"},{"location":"4.%20Operating%20System/os.html","title":"Vector's OS","text":"<p>Vector runs on an embedded Linux image built with Yocto Jethro.</p>"},{"location":"4.%20Operating%20System/os.html#what-is-yocto","title":"What is Yocto?","text":"<p>Yocto is a toolkit for creating your own embedded Linux \"distribution\".</p> <p>Vector does not \"run Yocto Linux\"!</p> <p>He runs embedded Linux which happens to be built with Yocto.</p>"},{"location":"4.%20Operating%20System/os.html#original-os-details","title":"(original) OS details","text":"<ul> <li>This is true for all Anki/DDL-created firmware:<ul> <li>Yocto Jethro</li> <li>maintained 2015-2017</li> <li>glibc 2.22</li> <li>softfp linking</li> </ul> </li> </ul>"},{"location":"4.%20Operating%20System/os.html#why-softfp-what-that-means","title":"Why softfp + what that means","text":"<p>Qualcomm provides proprietary binary \"blobs\" for some hardware communication. These are required for Bluetooth and camera functionality. These were built to run in an Android environment, and 32-bit Android is built with <code>softfp</code> for historical reasons, so the blobs were also built with <code>softfp</code>.</p> <p>This means that pre-compiled shared libraries made for SBCs like the Raspberry Pi won't work unless you jump through a few hoops.</p> <p>Example: Picovoice Porcupine, the new wake-word engine for WireOS, is shipped as a static library for various platforms. To get this to work in Vector's OS, I had to statically compile a <code>pv_server</code> program and have <code>vic-anim</code> communicate with it via IPC.</p>"},{"location":"4.%20Operating%20System/os.html#kernel","title":"Kernel","text":"<p>Vector runs an older version of the msm-3.18 kernel (3.18.66).</p>"},{"location":"4.%20Operating%20System/os.html#efforts-to-upgrade-this","title":"Efforts to upgrade this","text":"<p>WireOS is now using a the latest possible Yocto base - Yocto Walnascar. It uses glibc 2.41 (latest as of 2025).</p> <p>This means that all new CFW uses this base.</p>"},{"location":"4.%20Operating%20System/os.html#history","title":"History","text":"<p>DVT1 and early DVT2 prototype Vectors ran Android 7.1. Anki didn't really use any of the Android bits, and just dug down to the bare Linux underneath. They only used it while they were figuring out how to get Yocto working.</p>"},{"location":"5.%20Hardware/index.html","title":"Hardware","text":"<p>Vector has two main PCBs: a headboard and a bodyboard.</p> <p>TODO: these should be their own pages, each with pictures</p>"},{"location":"5.%20Hardware/index.html#headboard","title":"Headboard","text":"<p>The headboard is host to the main SoC, storage, RAM, camera, screen, Wi-Fi, BLE, IMU, and PMIC. It is the brains.</p> <ul> <li>SoC: Qualcomm APQ8009<ul> <li>Quad-core Cortex-A7<ul> <li>Max clock: 1.3GHz</li> <li>Vector is limited to 533 MHz to prevent overheating and to reduce power usage</li> </ul> </li> <li>Adreno 304<ul> <li>Weak, but can theoretically handle some AI tasks better than the CPU</li> <li>Anki experimented with this, but never ended up actually using it</li> </ul> </li> <li>One quirk: the ADSP is disabled, and the MDSP is repurposed as the ADSP.</li> </ul> </li> <li>eMCP: Kingston 04EMCP04-NL3DM627<ul> <li>4GB eMMC storage, 4Gb DDR3 RAM<ul> <li>(4Gb = 512MB)</li> </ul> </li> <li>eMCP = storage and RAM on one chip</li> </ul> </li> <li>Screen<ul> <li>Vector 1.0: 184x96, accepts RGB565 data over SPI</li> <li>Vector 2.0: 160x80, accepts bswapped RGB565 data over SPI</li> </ul> </li> <li>Camera<ul> <li>Vector 1.0: 720p, 90 degree FoV</li> <li>Vector 2.0: 2MP, TODO (who knows)</li> </ul> </li> <li>WLAN/BLE: WCN3660B</li> <li>PMIC: Qualcomm PM8916</li> <li>IMU: BMI160</li> </ul>"},{"location":"5.%20Hardware/index.html#bodyboard","title":"Bodyboard","text":"<p>The bodyboard is where all the robot bits (motors, sensors) connect to.</p> <ul> <li>MCU: STMicroelectonics STM32F030C8<ul> <li>8K RAM, 64K ROM</li> <li>Takes data from the sensors, outputs it into frames which the head can understand</li> <li>Receives data from the head, outputs it to the analog components (motors, LEDs)</li> </ul> </li> <li>Cliff sensors: 4 Lite-On proximity sensors</li> <li>Each motor has an encoder, it is unknown where these come from</li> <li>The gearboxes and motors are custom<ul> <li>The motors are a standard size, but Anki had a custom winding</li> <li>Replacements might work, but maybe not as well</li> </ul> </li> <li>Distance sensor: STMicroelectonics VL530LX</li> <li>Battery: FullRiver 320MaH<ul> <li>TODO: replacement battery links</li> </ul> </li> </ul>"},{"location":"6.%20Make%20Your%20Own%20CFW/1.%20prerequisites.html","title":"Prerequisites","text":"<p>Vector's software is complex and monstrous.</p>"},{"location":"6.%20Make%20Your%20Own%20CFW/1.%20prerequisites.html#technical-requirements","title":"Technical requirements","text":"<ul> <li>A beefy Linux x86_64 computer.<ul> <li>For reference, my desktop has:<ul> <li>Ryzen 5 5700X3D</li> <li>32GB 3200MHz RAM</li> </ul> </li> <li>For a comfortable experience, you should have at least 16GB of RAM.</li> </ul> </li> <li>A Vector.<ul> <li>You'll need something to test your code on.</li> <li>Preferably, you should have a 1.0 and a 2.0.</li> </ul> </li> <li><code>git</code>, <code>docker</code>, <code>wget</code><ul> <li>Everything is done in Docker. Don't worry, the build scripts initiate Docker automatically.</li> </ul> </li> </ul>"},{"location":"6.%20Make%20Your%20Own%20CFW/1.%20prerequisites.html#human-requirements","title":"Human requirements","text":"<ul> <li>Smarts<ul> <li>You need experience with C++. Lots of it.</li> <li>Don't be dependent on LLMs to help you. It won't be able to in lots of cases.</li> </ul> </li> <li>Activity<ul> <li>You have to be active. You should keep syncing the changes of WireOS into your OS, take care of user requests/bug reports, etc.</li> </ul> </li> <li>Exigence<ul> <li>Do you actually need to create a whole new CFW with its own name and possibly GitHub org, or do you just want to make a couple OTAs to show off a feature you created?</li> </ul> </li> </ul>"},{"location":"6.%20Make%20Your%20Own%20CFW/2.%20forking.html","title":"Forking","text":"<p>Fork wire-os and its submodules.</p>"},{"location":"6.%20Make%20Your%20Own%20CFW/2.%20forking.html#how","title":"How","text":"<ol> <li>Fork these repos. When choosing names, just replace the <code>wire-os</code> parts with the name you desire:<ul> <li>wire-os</li> <li>wire-os-victor</li> <li>wire-os-externals</li> </ul> </li> <li>Let's say, for example, we called it <code>diode-os</code>, and our GitHub username is diode123. Now we have diode123/diode-os, diode123/diode-os-victor, and diode123/diode-os-externals. Run in a Linux terminal:</li> </ol> <pre><code>cd ~\ngit clone https://github.com/diode123/diode-os --recursive\n</code></pre> <ol> <li>Replace the wire-os-victor submodule with yours:</li> </ol> <pre><code>cd diode-os\ngit rm -f anki/victor\nrm -rf anki/victor .git/modules/anki/victor\ngit commit -m \"remove wire-os\"\ngit submodule add https://github.com/diode123/diode-os-victor anki/victor\ngit commit -m \"new submodule\"\ngit push\n</code></pre> <ol> <li>Clone diode-os-victor separately and replace the EXTERNALS submodule.</li> </ol> <pre><code>cd ~\ngit clone https://github.com/diode123/diode-os-victor --recursive\ncd wire-os-victor\ngit rm -f EXTERNALS\nrm -rf EXTERNALS\ngit commit -m \"remove externals\"\ngit submodule add https://github.com/diode123/diode-os-externals EXTERNALS\ngit commit -m \"update externals\"\ngit push\n</code></pre>"},{"location":"6.%20Make%20Your%20Own%20CFW/3.%20how.html","title":"How to Develop","text":"<p>Here, we will perform two steps in one: learning how to make modifications to the code, and how to change the final screen in CCIS which describes what the builds are.</p>"},{"location":"6.%20Make%20Your%20Own%20CFW/3.%20how.html#what-ide-should-i-use","title":"What IDE should I use?","text":"<p>Anki tended to use Visual Studio Code - just use that.</p>"},{"location":"6.%20Make%20Your%20Own%20CFW/3.%20how.html#what-os-should-i-use","title":"What OS should I use?","text":"<p>An M-series Macs, or an x86_64 Linux PC - toolchains are only available for these platforms.</p>"},{"location":"6.%20Make%20Your%20Own%20CFW/3.%20how.html#lets-make-a-modification","title":"Let's make a modification!","text":"<ol> <li>Open up the diode-os-victor folder in VSCode.</li> <li>Open up <code>animProcess/src/cozmoAnim/faceDisplay/faceInfoScreenManager.cpp</code></li> <li>Modify lines 69-72 to match the details of your new CFW.</li> <li>Open a terminal and run <code>cd ~/diode-os-victor</code></li> <li>Build the code by running this: <code>./build/build-v.sh</code></li> </ol>"},{"location":"6.%20Make%20Your%20Own%20CFW/3.%20how.html#deploy","title":"Deploy","text":"<p>When you deploy code to a robot, his /anki folder gets replaced. This can be done on a laptop (reference: Ryzen 7840U, 16GB RAM). You do not need to build a whole OTA every time you want to test a change. ./build/build.sh just builds a /anki folder.</p> <ol> <li>Open a terminal and <code>cd ~/diode-os-victor</code></li> <li>Echo your robot's IP address to robot_ip.txt: <code>echo \"192.168.1.50\" &gt; robot_ip.txt</code></li> <li>Run: <code>curl -o robot_sshkey https://github.com/kercre123/unlocking-vector/raw/refs/heads/main/ssh_root_key</code></li> <li>Deploy: <code>./build/deploy-v.sh</code></li> </ol>"},{"location":"6.%20Make%20Your%20Own%20CFW/3.%20how.html#build-an-ota-with-your-change","title":"Build an OTA with your change","text":"<ol> <li>Run <code>cd ~/diode-os</code></li> <li>Update the submodule: </li> </ol> <pre><code>cd anki/victor\ngit pull origin main\ncd ../../\ngit add .\ngit commit -m \"vp\"\ngit push\n</code></pre> <ol> <li>Build:</li> </ol> <pre><code>./build/build.sh -bt dev -v 1\n</code></pre> <ol> <li>Your OTA will be at: ./_build/vicos-3.0.1.1d.ota.</li> </ol>"},{"location":"7.%20Terminology/terminology.html","title":"Terminology","text":"<ul> <li>VicOS - Vector's underlying OS (before the personality applications are added)<ul> <li>in WireOS and Viccyware and such, the underlying OS may still be referred to as VicOS</li> </ul> </li> <li>CFW - Custom FirmWare</li> <li>DDL - Digital Dream Labs</li> <li>SLAM - Simultaneous Localization And Mapping</li> </ul>"},{"location":"8.%20Contribute/Contribute.html","title":"Contribute","text":"<p>Guidelines you should follow.</p>"},{"location":"8.%20Contribute/Contribute.html#correctness","title":"Correctness","text":"<p>Double-check everything you type. It must be grammatically correct and everything should be spelled correctly.</p>"},{"location":"8.%20Contribute/Contribute.html#understandability","title":"Understandability","text":"<p>For example, if you are writing instructions, read it over under the mindset of a user. Are you able to understand it? Would someone who isn't super technically-inclined understand it?</p>"}]}